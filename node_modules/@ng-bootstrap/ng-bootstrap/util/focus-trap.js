import { DOCUMENT } from '@angular/common';
import { Inject, Injectable, NgZone } from '@angular/core';
var FOCUSABLE_ELEMENTS_SELECTOR = [
    'a[href]', 'button:not([disabled])', 'input:not([disabled]):not([type="hidden"])', 'select:not([disabled])',
    'textarea:not([disabled])', '[contenteditable]', '[tabindex]:not([tabindex="-1"])'
].join(', ');
var DIRECTION;
(function (DIRECTION) {
    DIRECTION[DIRECTION["BACKWARD"] = 0] = "BACKWARD";
    DIRECTION[DIRECTION["FORWARD"] = 1] = "FORWARD";
})(DIRECTION || (DIRECTION = {}));
/**
 * Class that enforce the browser focus to be trapped inside a DOM element.
 *
 * The implementation is rather simple, the class add a `focusin` listener on the document with capture phase.
 * Any focus event will then be caught, and therefore the class will only allow the one for elements contained inside
 * it's own element.
 *
 * In case the element is not contained, the class will determine which new element has to be focused based on the `tab`
 * navigation direction.
 *
 * Should not be used directly. Use only via {@link NgbFocusTrapFactory}
 */
var /**
 * Class that enforce the browser focus to be trapped inside a DOM element.
 *
 * The implementation is rather simple, the class add a `focusin` listener on the document with capture phase.
 * Any focus event will then be caught, and therefore the class will only allow the one for elements contained inside
 * it's own element.
 *
 * In case the element is not contained, the class will determine which new element has to be focused based on the `tab`
 * navigation direction.
 *
 * Should not be used directly. Use only via {@link NgbFocusTrapFactory}
 */
NgbFocusTrap = /** @class */ (function () {
    /**
     * @param _element The element around which focus will be trapped inside
     * @param autofocus Initially put the focus on specific element with a `ngbFocustrap` attribute. Will also remenber
     * and restore any previously focused element on destroy.
     * @param _document Document on which `focusin` and `keydown.TAB` events are listened
     * @param _ngZone The zone Angular is running in
     */
    function NgbFocusTrap(_element, autofocus, _document, _ngZone) {
        var _this = this;
        this._element = _element;
        this._document = _document;
        this._ngZone = _ngZone;
        this._direction = DIRECTION.FORWARD;
        this._previouslyFocused = null;
        this._endOfDocument = null;
        this._enforceFocus = this._enforceFocus.bind(this);
        this._detectDirection = this._detectDirection.bind(this);
        var eod = this._endOfDocument = this._document.createElement('i');
        eod.className = 'ngb-focustrap-eod';
        eod.tabIndex = 0;
        this._document.body.appendChild(eod);
        this._ngZone.runOutsideAngular(function () {
            _this._document.addEventListener('focusin', _this._enforceFocus, true);
            _this._document.addEventListener('keydown', _this._detectDirection);
            _this._removeDocumentListener = function () {
                _this._document.removeEventListener('focusin', _this._enforceFocus, true);
                _this._document.removeEventListener('keydown', _this._detectDirection);
            };
        });
        if (autofocus === true) {
            this._previouslyFocused = document.activeElement;
            this._focusInitial();
        }
    }
    Object.defineProperty(NgbFocusTrap.prototype, "focusableElement", {
        /**
         * Guess the next focusable element.
         * Computation is based on specific CSS selector and [tab] navigation direction
         */
        get: /**
           * Guess the next focusable element.
           * Computation is based on specific CSS selector and [tab] navigation direction
           */
        function () {
            var list = this._element.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR);
            return this._direction === DIRECTION.BACKWARD ? list[list.length - 1] : list[0];
        },
        enumerable: true,
        configurable: true
    });
    /** Detect if incoming focus event should be prevented or not */
    /** Detect if incoming focus event should be prevented or not */
    NgbFocusTrap.prototype._enforceFocus = /** Detect if incoming focus event should be prevented or not */
    function (event) {
        var _this = this;
        var target = event.target;
        if (this._document !== target && this._element !== target && !this._element.contains(target)) {
            this._ngZone.run(function () {
                var element = _this.focusableElement;
                if (element) {
                    element.focus();
                    event.stopPropagation();
                }
            });
        }
    };
    /** Event handler detecting current `tab` navigation direction */
    /** Event handler detecting current `tab` navigation direction */
    NgbFocusTrap.prototype._detectDirection = /** Event handler detecting current `tab` navigation direction */
    function (event) {
        var shiftKey = event.shiftKey, key = event.key;
        if (key === 'Tab') {
            this._direction = shiftKey ? DIRECTION.BACKWARD : DIRECTION.FORWARD;
        }
    };
    /** Try to set focus on the first found element that has an ngbAutofocus attribute */
    /** Try to set focus on the first found element that has an ngbAutofocus attribute */
    NgbFocusTrap.prototype._focusInitial = /** Try to set focus on the first found element that has an ngbAutofocus attribute */
    function () {
        var element = this._element.querySelector('[ngbAutofocus]');
        if (element) {
            element.focus();
        }
    };
    /**
     * Destroys the focustrap by removing all event listeners set on document.
     *
     * Eventually put the focus back on the previously focused element at the time
     * focustrap has been initialized.
     */
    /**
       * Destroys the focustrap by removing all event listeners set on document.
       *
       * Eventually put the focus back on the previously focused element at the time
       * focustrap has been initialized.
       */
    NgbFocusTrap.prototype.destroy = /**
       * Destroys the focustrap by removing all event listeners set on document.
       *
       * Eventually put the focus back on the previously focused element at the time
       * focustrap has been initialized.
       */
    function () {
        this._removeDocumentListener();
        this._document.body.removeChild(this._endOfDocument);
        if (this._previouslyFocused) {
            this._previouslyFocused.focus();
        }
    };
    return NgbFocusTrap;
}());
/**
 * Class that enforce the browser focus to be trapped inside a DOM element.
 *
 * The implementation is rather simple, the class add a `focusin` listener on the document with capture phase.
 * Any focus event will then be caught, and therefore the class will only allow the one for elements contained inside
 * it's own element.
 *
 * In case the element is not contained, the class will determine which new element has to be focused based on the `tab`
 * navigation direction.
 *
 * Should not be used directly. Use only via {@link NgbFocusTrapFactory}
 */
export { NgbFocusTrap };
/**
 * Factory service to easily create a `NgbFocusTrap` instance on an element
 */
var NgbFocusTrapFactory = /** @class */ (function () {
    function NgbFocusTrapFactory(_document, _ngZone) {
        this._document = _document;
        this._ngZone = _ngZone;
    }
    /**
     * Create an instance of {@link NgbFocusTrap} and return it
     * @param element HTMLElement to trap focus inside
     * @param autofocus Whether the focustrap should automatically move focus into the trapped element upon
     * initialization and return focus to the previous activeElement upon destruction.
     */
    /**
       * Create an instance of {@link NgbFocusTrap} and return it
       * @param element HTMLElement to trap focus inside
       * @param autofocus Whether the focustrap should automatically move focus into the trapped element upon
       * initialization and return focus to the previous activeElement upon destruction.
       */
    NgbFocusTrapFactory.prototype.create = /**
       * Create an instance of {@link NgbFocusTrap} and return it
       * @param element HTMLElement to trap focus inside
       * @param autofocus Whether the focustrap should automatically move focus into the trapped element upon
       * initialization and return focus to the previous activeElement upon destruction.
       */
    function (element, autofocus) {
        if (autofocus === void 0) { autofocus = false; }
        return new NgbFocusTrap(element, autofocus, this._document, this._ngZone);
    };
    NgbFocusTrapFactory.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    NgbFocusTrapFactory.ctorParameters = function () { return [
        { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
        { type: NgZone, },
    ]; };
    return NgbFocusTrapFactory;
}());
export { NgbFocusTrapFactory };
//# sourceMappingURL=focus-trap.js.map