{"version":3,"file":"focus-trap.js","sourceRoot":"","sources":["../../src/util/focus-trap.ts"],"names":[],"mappings":"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","sourcesContent":["import {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable, NgZone} from '@angular/core';\n\nconst FOCUSABLE_ELEMENTS_SELECTOR = [\n  'a[href]', 'button:not([disabled])', 'input:not([disabled]):not([type=\"hidden\"])', 'select:not([disabled])',\n  'textarea:not([disabled])', '[contenteditable]', '[tabindex]:not([tabindex=\"-1\"])'\n].join(', ');\n\nenum DIRECTION {\n  BACKWARD,\n  FORWARD\n}\n\n/**\n * Class that enforce the browser focus to be trapped inside a DOM element.\n *\n * The implementation is rather simple, the class add a `focusin` listener on the document with capture phase.\n * Any focus event will then be caught, and therefore the class will only allow the one for elements contained inside\n * it's own element.\n *\n * In case the element is not contained, the class will determine which new element has to be focused based on the `tab`\n * navigation direction.\n *\n * Should not be used directly. Use only via {@link NgbFocusTrapFactory}\n */\nexport class NgbFocusTrap {\n  private _removeDocumentListener;\n  private _direction: DIRECTION = DIRECTION.FORWARD;\n  private _previouslyFocused: HTMLElement | null = null;\n  private _endOfDocument: HTMLElement | null = null;\n\n  /**\n   * Guess the next focusable element.\n   * Computation is based on specific CSS selector and [tab] navigation direction\n   */\n  private get focusableElement(): HTMLElement {\n    const list: NodeListOf<HTMLElement> = this._element.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR);\n    return this._direction === DIRECTION.BACKWARD ? list[list.length - 1] : list[0];\n  }\n\n  /**\n   * @param _element The element around which focus will be trapped inside\n   * @param autofocus Initially put the focus on specific element with a `ngbFocustrap` attribute. Will also remenber\n   * and restore any previously focused element on destroy.\n   * @param _document Document on which `focusin` and `keydown.TAB` events are listened\n   * @param _ngZone The zone Angular is running in\n   */\n  constructor(private _element: HTMLElement, autofocus: boolean, private _document: Document, private _ngZone: NgZone) {\n    this._enforceFocus = this._enforceFocus.bind(this);\n    this._detectDirection = this._detectDirection.bind(this);\n\n    const eod = this._endOfDocument = this._document.createElement('i');\n    eod.className = 'ngb-focustrap-eod';\n    eod.tabIndex = 0;\n    this._document.body.appendChild(eod);\n\n    this._ngZone.runOutsideAngular(() => {\n      this._document.addEventListener('focusin', this._enforceFocus, true);\n      this._document.addEventListener('keydown', this._detectDirection);\n\n      this._removeDocumentListener = () => {\n        this._document.removeEventListener('focusin', this._enforceFocus, true);\n        this._document.removeEventListener('keydown', this._detectDirection);\n      }\n    });\n\n    if (autofocus === true) {\n      this._previouslyFocused = document.activeElement as HTMLElement;\n      this._focusInitial();\n    }\n  }\n\n  /** Detect if incoming focus event should be prevented or not */\n  private _enforceFocus(event) {\n    const {target} = event;\n    if (this._document !== target && this._element !== target && !this._element.contains(target)) {\n      this._ngZone.run(() => {\n        const element = this.focusableElement;\n        if (element) {\n          element.focus();\n          event.stopPropagation();\n        }\n      });\n    }\n  }\n\n  /** Event handler detecting current `tab` navigation direction */\n  private _detectDirection(event) {\n    const {shiftKey, key} = event;\n    if (key === 'Tab') {\n      this._direction = shiftKey ? DIRECTION.BACKWARD : DIRECTION.FORWARD;\n    }\n  }\n\n  /** Try to set focus on the first found element that has an ngbAutofocus attribute */\n  private _focusInitial() {\n    const element = this._element.querySelector('[ngbAutofocus]') as HTMLElement;\n    if (element) {\n      element.focus();\n    }\n  }\n\n  /**\n   * Destroys the focustrap by removing all event listeners set on document.\n   *\n   * Eventually put the focus back on the previously focused element at the time\n   * focustrap has been initialized.\n   */\n  destroy() {\n    this._removeDocumentListener();\n    this._document.body.removeChild(this._endOfDocument);\n    if (this._previouslyFocused) {\n      this._previouslyFocused.focus();\n    }\n  }\n}\n\n/**\n * Factory service to easily create a `NgbFocusTrap` instance on an element\n */\n@Injectable()\nexport class NgbFocusTrapFactory {\n  constructor(@Inject(DOCUMENT) private _document: Document, private _ngZone: NgZone) {}\n\n  /**\n   * Create an instance of {@link NgbFocusTrap} and return it\n   * @param element HTMLElement to trap focus inside\n   * @param autofocus Whether the focustrap should automatically move focus into the trapped element upon\n   * initialization and return focus to the previous activeElement upon destruction.\n   */\n  create(element: HTMLElement, autofocus = false): NgbFocusTrap {\n    return new NgbFocusTrap(element, autofocus, this._document, this._ngZone);\n  }\n}\n"]}